import "./chunk-CSAU5B4Q.js";

// node_modules/wavesurfer.js/dist/plugins/record.esm.js
function t(t2, i2, e2, s2) {
  return new (e2 || (e2 = Promise))(function(r2, o2) {
    function n(t3) {
      try {
        d(s2.next(t3));
      } catch (t4) {
        o2(t4);
      }
    }
    function a(t3) {
      try {
        d(s2.throw(t3));
      } catch (t4) {
        o2(t4);
      }
    }
    function d(t3) {
      var i3;
      t3.done ? r2(t3.value) : (i3 = t3.value, i3 instanceof e2 ? i3 : new e2(function(t4) {
        t4(i3);
      })).then(n, a);
    }
    d((s2 = s2.apply(t2, i2 || [])).next());
  });
}
var i = class {
  constructor() {
    this.listeners = {};
  }
  on(t2, i2, e2) {
    if (this.listeners[t2] || (this.listeners[t2] = /* @__PURE__ */ new Set()), this.listeners[t2].add(i2), null == e2 ? void 0 : e2.once) {
      const e3 = () => {
        this.un(t2, e3), this.un(t2, i2);
      };
      return this.on(t2, e3), e3;
    }
    return () => this.un(t2, i2);
  }
  un(t2, i2) {
    var e2;
    null === (e2 = this.listeners[t2]) || void 0 === e2 || e2.delete(i2);
  }
  once(t2, i2) {
    return this.on(t2, i2, { once: true });
  }
  unAll() {
    this.listeners = {};
  }
  emit(t2, ...i2) {
    this.listeners[t2] && this.listeners[t2].forEach((t3) => t3(...i2));
  }
};
var e = class extends i {
  constructor(t2) {
    super(), this.subscriptions = [], this.options = t2;
  }
  onInit() {
  }
  _init(t2) {
    this.wavesurfer = t2, this.onInit();
  }
  destroy() {
    this.emit("destroy"), this.subscriptions.forEach((t2) => t2());
  }
};
var s = class extends i {
  constructor() {
    super(...arguments), this.unsubscribe = () => {
    };
  }
  start() {
    this.unsubscribe = this.on("tick", () => {
      requestAnimationFrame(() => {
        this.emit("tick");
      });
    }), this.emit("tick");
  }
  stop() {
    this.unsubscribe();
  }
  destroy() {
    this.unsubscribe();
  }
};
var r = ["audio/webm", "audio/wav", "audio/mpeg", "audio/mp4", "audio/mp3"];
var o = class _o extends e {
  constructor(t2) {
    var i2, e2, r2, o2;
    super(Object.assign(Object.assign({}, t2), { audioBitsPerSecond: null !== (i2 = t2.audioBitsPerSecond) && void 0 !== i2 ? i2 : 128e3, scrollingWaveform: null !== (e2 = t2.scrollingWaveform) && void 0 !== e2 && e2, scrollingWaveformWindow: null !== (r2 = t2.scrollingWaveformWindow) && void 0 !== r2 ? r2 : 5, renderRecordedAudio: null === (o2 = t2.renderRecordedAudio) || void 0 === o2 || o2 })), this.stream = null, this.mediaRecorder = null, this.dataWindow = null, this.isWaveformPaused = false, this.lastStartTime = 0, this.lastDuration = 0, this.duration = 0, this.timer = new s(), this.subscriptions.push(this.timer.on("tick", () => {
      const t3 = performance.now() - this.lastStartTime;
      this.duration = this.isPaused() ? this.duration : this.lastDuration + t3, this.emit("record-progress", this.duration);
    }));
  }
  static create(t2) {
    return new _o(t2 || {});
  }
  renderMicStream(t2) {
    const i2 = new AudioContext(), e2 = i2.createMediaStreamSource(t2), s2 = i2.createAnalyser();
    e2.connect(s2);
    const r2 = s2.frequencyBinCount, o2 = new Float32Array(r2);
    let n;
    const a = Math.floor((this.options.scrollingWaveformWindow || 0) * i2.sampleRate), d = () => {
      var t3;
      if (this.isWaveformPaused)
        return void (n = requestAnimationFrame(d));
      if (s2.getFloatTimeDomainData(o2), this.options.scrollingWaveform) {
        const t4 = Math.min(a, this.dataWindow ? this.dataWindow.length + r2 : r2), i4 = new Float32Array(a);
        if (this.dataWindow) {
          const e3 = Math.max(0, a - this.dataWindow.length);
          i4.set(this.dataWindow.slice(-t4 + r2), e3);
        }
        i4.set(o2, a - r2), this.dataWindow = i4;
      } else
        this.dataWindow = o2;
      const i3 = this.options.scrollingWaveformWindow;
      this.wavesurfer && (null !== (t3 = this.originalOptions) && void 0 !== t3 || (this.originalOptions = { cursorWidth: this.wavesurfer.options.cursorWidth, interact: this.wavesurfer.options.interact }), this.wavesurfer.options.cursorWidth = 0, this.wavesurfer.options.interact = false, this.wavesurfer.load("", [this.dataWindow], i3)), n = requestAnimationFrame(d);
    };
    return d(), { onDestroy: () => {
      cancelAnimationFrame(n), null == e2 || e2.disconnect(), null == i2 || i2.close();
    }, onEnd: () => {
      this.isWaveformPaused = true, cancelAnimationFrame(n), this.stopMic();
    } };
  }
  startMic(i2) {
    return t(this, void 0, void 0, function* () {
      let t2;
      try {
        t2 = yield navigator.mediaDevices.getUserMedia({ audio: !(null == i2 ? void 0 : i2.deviceId) || { deviceId: i2.deviceId } });
      } catch (t3) {
        throw new Error("Error accessing the microphone: " + t3.message);
      }
      const { onDestroy: e2, onEnd: s2 } = this.renderMicStream(t2);
      return this.subscriptions.push(this.once("destroy", e2)), this.subscriptions.push(this.once("record-end", s2)), this.stream = t2, t2;
    });
  }
  stopMic() {
    this.stream && (this.stream.getTracks().forEach((t2) => t2.stop()), this.stream = null, this.mediaRecorder = null);
  }
  startRecording(i2) {
    return t(this, void 0, void 0, function* () {
      const t2 = this.stream || (yield this.startMic(i2));
      this.dataWindow = null;
      const e2 = this.mediaRecorder || new MediaRecorder(t2, { mimeType: this.options.mimeType || r.find((t3) => MediaRecorder.isTypeSupported(t3)), audioBitsPerSecond: this.options.audioBitsPerSecond });
      this.mediaRecorder = e2, this.stopRecording();
      const s2 = [];
      e2.ondataavailable = (t3) => {
        t3.data.size > 0 && s2.push(t3.data);
      };
      const o2 = (t3) => {
        var i3;
        const r2 = new Blob(s2, { type: e2.mimeType });
        this.emit(t3, r2), this.options.renderRecordedAudio && (this.applyOriginalOptionsIfNeeded(), null === (i3 = this.wavesurfer) || void 0 === i3 || i3.load(URL.createObjectURL(r2)));
      };
      e2.onpause = () => o2("record-pause"), e2.onstop = () => o2("record-end"), e2.start(), this.lastStartTime = performance.now(), this.lastDuration = 0, this.duration = 0, this.isWaveformPaused = false, this.timer.start(), this.emit("record-start");
    });
  }
  getDuration() {
    return this.duration;
  }
  isRecording() {
    var t2;
    return "recording" === (null === (t2 = this.mediaRecorder) || void 0 === t2 ? void 0 : t2.state);
  }
  isPaused() {
    var t2;
    return "paused" === (null === (t2 = this.mediaRecorder) || void 0 === t2 ? void 0 : t2.state);
  }
  isActive() {
    var t2;
    return "inactive" !== (null === (t2 = this.mediaRecorder) || void 0 === t2 ? void 0 : t2.state);
  }
  stopRecording() {
    var t2;
    this.isActive() && (null === (t2 = this.mediaRecorder) || void 0 === t2 || t2.stop(), this.timer.stop());
  }
  pauseRecording() {
    var t2, i2;
    this.isRecording() && (this.isWaveformPaused = true, null === (t2 = this.mediaRecorder) || void 0 === t2 || t2.requestData(), null === (i2 = this.mediaRecorder) || void 0 === i2 || i2.pause(), this.timer.stop(), this.lastDuration = this.duration);
  }
  resumeRecording() {
    var t2;
    this.isPaused() && (this.isWaveformPaused = false, null === (t2 = this.mediaRecorder) || void 0 === t2 || t2.resume(), this.timer.start(), this.lastStartTime = performance.now(), this.emit("record-resume"));
  }
  static getAvailableAudioDevices() {
    return t(this, void 0, void 0, function* () {
      return navigator.mediaDevices.enumerateDevices().then((t2) => t2.filter((t3) => "audioinput" === t3.kind));
    });
  }
  destroy() {
    this.applyOriginalOptionsIfNeeded(), super.destroy(), this.stopRecording(), this.stopMic();
  }
  applyOriginalOptionsIfNeeded() {
    this.wavesurfer && this.originalOptions && (this.wavesurfer.options.cursorWidth = this.originalOptions.cursorWidth, this.wavesurfer.options.interact = this.originalOptions.interact, delete this.originalOptions);
  }
};
export {
  o as default
};
//# sourceMappingURL=wavesurfer__js_dist_plugins_record__esm__js.js.map
